---
title: 'Shai-Hulud 2.0 攻撃を受けての反省と対策'
pubDate: "2025-12-27"
description: 'Shai-Hulud 2.0 攻撃'
---

「乗っ取られてる？」友人から連絡が届いた。

慌ててGitHubを確認すると、自分のアカウントから身に覚えのない変更が大量に作成されていた。

![GitHubのcommit履歴のスクリーンショット。様々なリポジトリに対して複数のcommitが作成されている。](./history.png)

わけもわからないまま関係者への連絡、GitHubのパスワード変更、APIキーの無効化などその場でできる限りの対応を行った。

## 何が起こったのか？

調査の結果、[Shai-hulud 2.0](https://www.trendmicro.com/ja_jp/research/25/k/shai-hulud-2-0-targets-cloud-and-developer-systems.html)と呼ばれるnpmサプライチェーン攻撃の被害を受けていたことがわかった。

実際に私が受けた被害は以下の通り。

- GitHubアカウントが乗っ取られ、悪意のある変更が加えられた
  - アクセス権のある全リポジトリのREADMEが改ざんされた（[同様の被害報告](https://github.com/orgs/community/discussions/180432)）
  - privateリポジトリがpublicに変更された
- 自分のアカウントに新しいリポジトリが作成され、環境変数やAPIキーなどの機密情報が外部から閲覧可能な状態で公開された

### Shai-hulud 2.0とは

Shai-hulud 2.0の攻撃メカニズムは以下のようになっている。

1. 正規のnpmパッケージメンテナーの認証情報を不正入手し、アカウントを乗っ取る
2. 乗っ取ったアカウントを使って人気パッケージをトロイの木馬化する
3. 感染パッケージがインストールされると、preinstallスクリプトでマルウェアが自動実行される
4. マルウェアはexfiltration用のリポジトリを作成し、環境内のシークレットをpushする
5. 盗んだnpmトークンを使ってパッケージの不正バージョンを公開し、さらに被害を拡大する

### 私の感染経路

私の場合、npm経由ではなくVSCode拡張機能経由での感染だった。

2年ほど前の開発で導入した拡張機能「vs-asyncapi-preview」に、悪意のあるバージョンがpushされていた。Cursorを起動した際、拡張機能が自動アップデートされるタイミングで感染したと考えられる。

詳細については、[AsyncAPI公式ブログのポストモーテム記事](https://www.asyncapi.com/blog/shai-hulud-postmortem)で解説されている。

## 攻撃を受けての反省

npmサプライチェーン攻撃については、会社でも情報共有されており知識としては知っていた。しかし、自分個人には関係のない話だろうと高をくくってしまっていた。

そんな自分が実際に攻撃を受け、過去に一緒に開発したメンバーや所属しているOrganizationのメンバーにまで迷惑をかけることになってしまった。

そこで、自分のエンジニアとしての技術力の無さと意識の低さが露呈した。

- CLIに慣れておらず、どう調査するべきかも手探りな状態でなんとか原因を特定した
- トークンの保存場所すら把握できていないなど、普段の管理が杜撰だった
- 対応策をなんとなく知っていても、実践はしておらず、何も身についていなかった

この経験を真摯に受け止め、自分のセキュリティ周りを見直すことにした。

## 行った対策

### 1. dev containerの導入

今回の感染の根本原因は、**PC全体に影響が及ぶグローバルな環境で開発していた**ことにあった。

実際、2年前のプロジェクトで使った「vs-asyncapi-preview」という拡張機能を放置していたことで、全プロジェクトに影響が及んだ。これは拡張機能経由での感染だったが、Shai-Hulud 2.0の本来の攻撃経路であるnpm経由の場合も同様である。

ホストマシンのターミナルで直接`npm install`を実行すると、先述した攻撃メカニズムの通り、preinstallスクリプトが自動実行される。悪意のあるパッケージが含まれていた場合、環境変数に保存された全プロジェクトの機密情報（GitHubトークン、AWSクレデンシャル等）が一度に流出してしまう。

この問題を解決するために、**開発環境の分離（Isolation）**を徹底する。

dev containerを導入することで、プロジェクトごとに独立したコンテナ環境を構築する。これにより以下が実現できる：

- **影響範囲の限定化**: 万が一攻撃を受けても、被害はそのコンテナ内に閉じ込められる
- **プロジェクト固有の依存関係管理**: 拡張機能やツールをプロジェクトごとに管理できる

今回の経験を機に、今後のあらゆる開発でDev Containerを使用することにした。これまでコンテナ技術にしっかりと向き合ってこなかったため、学び直しとしてdev containerの具体的な設定方法に関して改めて記事にする予定だ。

### 2. pnpmの設定見直し

私の感染経路は拡張機能起因だったが、npm周りのセキュリティ管理をちゃんとできていたかと言われるとそうではない。

npmパッケージの`preinstall`や`postinstall`スクリプトは、パッケージが安全性の評価を受ける前に、開発者の全権限でインターネット上の任意のコードを実行する。認証情報、ソースコード、ファイルシステム全体にアクセスできてしまう。悪意あるバージョンが公開されると、`npm install`を実行しただけで感染してしまう。

npmパッケージをインストールすることに危険性があることを認め、正しく運用していくべきだ。pnpmには強力なサプライチェーンセキュリティ機能が備わっているので、これらを活用することにした。

具体的には以下の設定を適用した。それぞれの設定について解説する。

```yaml
# pnpm-workspace.yaml
strictDepBuilds: true
onlyBuiltDependencies:
  - '@biomejs/biome'
  - '@swc/core'
  - esbuild
  - sharp

minimumReleaseAge: 10080 # 7日

trustPolicy: no-downgrade

blockExoticSubdeps: true
```

詳細は[pnpmのサプライチェーンセキュリティに関するドキュメント](https://pnpm.io/supply-chain-security)および[pnpm公式ブログの解説記事](https://pnpm.io/blog/2025/12/05/newsroom-npm-supply-chain-security)を参照のこと。

#### 2.1. ライフサイクルスクリプト管理

`strictDepBuilds: true`を設定すると、pnpmは`preinstall`や`postinstall`といったスクリプトを持つパッケージを検出し、インストールを中断する。

これにより、どのパッケージにスクリプトがあるか特定でき、スクリプトの内容を調査した上で実行を許可するかどうかユーザーが判断できる。許可するパッケージは`onlyBuiltDependencies`に追加することで、そのパッケージのみスクリプト実行が許可される。

#### 2.2. リリース・クールダウン

新しいパッケージが公開されてすぐに利用するのではなく、一定期間待ってから利用することで、悪意のあるパッケージが混入するリスクを減らす。`minimumReleaseAge`で公開からの経過時間（分単位）を指定できる。

常に最新のものが最良とは限らない。時間が経った方が、コミュニティが問題を発見しやすい。特定のパッケージだけ即時に最新版を入れたい場合は、`minimumReleaseAgeExclude`で除外できる。

#### 2.3. Trust Policy

npmはパッケージの公開方法に応じて3つの信頼レベルを区別している。

- **Trusted Publisher**: GitHub ActionsでOIDCトークンとnpm provenanceを使用して公開
- **Provenance**: CI/CDシステムからの署名付き証明
- **No Trust Evidence**: ユーザー名/パスワードまたはトークン認証で公開

`trustPolicy: no-downgrade`を設定すると、新しいバージョンの認証レベルが古いバージョンよりも低い場合、pnpmはインストールを拒否する。

攻撃者が開発者のアカウントを乗っ取り、不正なパッケージを公開した場合、CI/CDシステムからの証明（provenance）がないため信頼レベルが低下する。この設定により、そのような攻撃の影響を受けないようにできる。

#### 2.4. 間接的な依存関係のブロック

`blockExoticSubdeps: true`を設定すると、間接的な依存関係（transitive dependencies）がGitリポジトリやURLを直接参照している場合にインストールをブロックする。正規のnpmレジストリを経由しない依存関係は、検証が困難なため危険性が高い。

### 3. クレデンシャルの秘匿

dev containerで環境を分離しても、クレデンシャル自体が平文で保存されていれば意味がない。そもそも今回の攻撃は、ファイルシステム上に保存されたクレデンシャルを狙ったものだった。

GitHubのリポジトリにコマンドラインからアクセスするには、[HTTPSとSSHの2種類の方法](https://docs.github.com/ja/authentication/keeping-your-account-and-data-secure/about-authentication-to-github#authenticating-with-the-command-line)がある。HTTPSではPersonal Access Token、SSHでは秘密鍵を使って認証を行う。

どちらの方法でも、認証情報が漏洩すればアカウントを乗っ取られる。そして多くの場合、これらの認証情報は以下のような場所に**平文で保存**されている。

- `~/.ssh/` - SSH秘密鍵
- `~/.zshrc`や`~/.bashrc` - 環境変数として設定されたトークン
- `~/.gitconfig` - Git credential helper経由で保存されたトークン

マルウェアに感染すれば、これらのファイルは簡単に読み取られてしまう。今回のShai-Hulud 2.0もまさにこれらを標的としていた。

この問題を解決するために、1Passwordを使った認証情報の管理に移行した。具体的には、[1PasswordのSSHエージェント機能](https://developer.1password.com/docs/ssh/get-started/)を活用する。

この機能を使うと、SSH秘密鍵を1Passwordの暗号化されたボールト内に保存し、Git操作時にTouch IDやパスワードによる認証を経ないと使用できないようにできる。つまり、ファイルシステム上に秘密鍵が存在しなくなるため、マルウェアが`~/.ssh/`を読み取っても何も得られない。

1Passwordを経由することで以下のメリットがある：

- **生体認証による保護**: Touch ID/Face IDを経ないと認証情報にアクセスできない
- **平文ファイルの排除**: ファイルシステム上に機密情報が存在しない
- **監査ログ**: いつ・どのアプリケーションが認証情報を使用したか記録される

## まとめ


npmサプライチェーン攻撃の存在は知っていたが、自分には関係ないと思い込み、何の対策も講じていなかった。その結果、攻撃を受けてから慌てて対応することになり、周囲にも迷惑をかけてしまった。

今回の攻撃を受けて、以下の3つの対策を実施した。

1. **dev containerの導入**: プロジェクトごとに環境を分離し、被害の影響範囲を限定する
2. **pnpmのセキュリティ設定**: ライフサイクルスクリプトの制御、リリース・クールダウン、Trust Policyなどを活用し、サプライチェーン攻撃のリスクを低減する
3. **1Passwordによるクレデンシャル管理**: 認証情報を平文でファイルに保存せず、生体認証で保護する

対策を行うことで、なんとなく聞いたことがあった知識を自分の経験にすることができた。今後はメリットのあるものをどんどん活用していき、多角的な知識をしっかりつけるようにしたいと思った。



## 参考

- [Shai-hulud 2.0キャンペーンがクラウドと開発者エコシステムを標的に](https://www.trendmicro.com/ja_jp/research/25/k/shai-hulud-2-0-targets-cloud-and-developer-systems.html)
- [Shai-Hulud — What Happened, How We Fixed It, and What We Learned](https://www.asyncapi.com/blog/shai-hulud-postmortem)